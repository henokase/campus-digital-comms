# Code-First Swagger (OpenAPI 3.0) Implementation Plan

## Goal
Add **runtime API documentation** using:
- `swagger-jsdoc` (generate OpenAPI JSON from JSDoc blocks)
- `swagger-ui-express` (serve interactive Swagger UI)

Primary objective is to document **Gateway-facing endpoints** (what clients call), because:
- it’s the system’s public API surface
- auth/RBAC behavior lives at gateway level
- it avoids duplicating service-internal docs

We can optionally add per-service docs later.

## Scope (Phase 1)
- **Expose Swagger UI** from API Gateway at:
  - `GET /api-docs` (UI)
  - `GET /api-docs.json` (raw spec)
- Use OpenAPI 3.0 with:
  - **Bearer JWT** auth (`Authorization: Bearer <token>`)
  - tags per module: Auth, Announcements, Notifications, Feedback, Analytics
- Document request/response schemas and common errors.

## Repo strategy
### Where to host the docs
- Implementation will live in: `backend/services/api-gateway`
- Public docs endpoints served by the gateway.

### Where to store generated spec artifacts (optional, for submission)
Because rubric may require a file artifact, we can export:
- `docs/api/api-gateway.openapi.json`

This should be generated by a script to avoid drift.

## Key decisions
### A) Gateway-only vs per-service Swagger
- **Phase 1: Gateway-only** (recommended)
  - Pros:
    - single coherent API surface
    - avoids duplicated endpoints across services
    - easier for graders/clients
  - Cons:
    - internal service endpoints not separately visible

- **Phase 2: Per-service Swagger** (optional)
  - Each service exposes `/api-docs` with its internal routes.
  - Gateway docs remains the “public API”.

### B) Source of truth for route documentation
- Code-first JSDoc blocks directly above gateway routes.
- Keep docs close to implementation so changes are less likely to diverge.

### C) RBAC in OpenAPI
We will represent RBAC via:
- `security` requirement (BearerAuth)
- **role notes** in `description` and response codes:
  - `401` unauthenticated
  - `403` forbidden for wrong role

We will not attempt dynamic role constraints in OpenAPI beyond documentation.

## Implementation milestones
### Milestone 1 — Add Swagger dependencies
In `backend/services/api-gateway/package.json`:
- add dependencies:
  - `swagger-jsdoc`
  - `swagger-ui-express`

### Milestone 2 — Add Swagger wiring module
Create a small module (example path):
- `backend/services/api-gateway/src/swagger.js`

Responsibilities:
- build OpenAPI `definition`:
  - `openapi: 3.0.0`
  - `info` (title/version/description)
  - `servers` (base URL)
  - `components.securitySchemes.BearerAuth`
  - `components.schemas` for shared models
- generate spec via `swaggerJSDoc({ definition, apis: [...] })`
- export:
  - `swaggerSpec`
  - `swaggerUiOptions`

### Milestone 3 — Expose endpoints in gateway
In gateway app setup (where Express app is configured):
- mount:
  - `app.get('/api-docs.json', (req, res) => res.json(swaggerSpec))`
  - `app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, swaggerUiOptions))`

Notes:
- If you already have `/health` and `/api/*` routes, Swagger should mount near the end but before error handlers.

### Milestone 4 — Add minimal JSDoc blocks to verify generation
Start with a small subset:
- `/api/auth/register`
- `/api/auth/login`

Confirm `GET /api-docs.json` has paths.

### Milestone 5 — Document all Gateway routes (incremental)
Add JSDoc blocks for:
- Auth
  - `POST /api/auth/register`
  - `POST /api/auth/login`
  - `GET /api/auth/profile`
- Announcements
  - `GET /api/announcements`
  - `POST /api/announcements` (faculty/admin)
  - `GET /api/announcements/{id}`
  - `PUT /api/announcements/{id}` (faculty/admin)
  - `DELETE /api/announcements/{id}` (faculty/admin)
  - `POST /api/announcements/{id}/publish` (faculty/admin)
- Notifications
  - `GET /api/notifications`
  - `GET /api/notifications/unread-count`
  - `PUT /api/notifications/{id}/read`
- Feedback
  - `POST /api/feedback`
  - `PATCH /api/feedback/{id}`
  - `GET /api/feedback/my`
  - `GET /api/feedback/announcement/{announcementId}`
- Analytics (faculty/admin)
  - `GET /api/analytics/dashboard`
  - `GET /api/analytics/announcement/{announcementId}`
  - `GET /api/analytics/top-announcements`

We’ll document:
- parameters (`path`, `query`)
- request bodies
- response shapes
- error responses

## Documentation block template (route-level)
Use this pattern directly above the route handler in the gateway route file.

Example: `POST /api/auth/login`

```js
/**
 * @openapi
 * /api/auth/login:
 *   post:
 *     tags:
 *       - Auth
 *     summary: Login
 *     description: Logs a user in and returns a JWT.
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/LoginRequest'
 *     responses:
 *       200:
 *         description: OK
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/LoginResponse'
 *       401:
 *         description: Invalid credentials
 */
```

## Shared schemas (components.schemas)
Define these centrally in the gateway swagger definition so route blocks can reference them.

Minimum recommended schemas:
- `ErrorResponse`
- `RegisterRequest`
- `LoginRequest`
- `LoginResponse`
- `User`
- `Announcement`
- `CreateAnnouncementRequest`
- `UpdateAnnouncementRequest`
- `Notification`
- `Feedback`
- `CreateFeedbackRequest`
- `UpdateFeedbackRequest`
- `AnalyticsDashboard`
- `AnnouncementMetrics`
- `TopAnnouncementsResponse`

Notes:
- If your API responses nest objects (e.g., `{ announcement: {...} }`), reflect that shape.
- Keep schemas accurate but don’t overcomplicate with every optional field on day 1.

## Security modeling
In `definition.components.securitySchemes`:
- `BearerAuth` type `http`, scheme `bearer`, bearerFormat `JWT`

Then for protected endpoints add:

```yaml
security:
  - BearerAuth: []
```

Also add role notes in `description`, for example:
- “Requires role: faculty or admin.”

## How swagger-jsdoc finds docs
We’ll configure:
- `apis: [...]` pointing to files containing JSDoc blocks.

Options:
- Point to gateway route files only (recommended):
  - `src/**/*.js`
  - or narrower: `src/app.js`, `src/routes/*.js`

Important:
- Keep JSDoc blocks in the same files as the route definitions.

## Testing & verification
### Local checks
- Start stack and verify:
  - `GET http://localhost:3000/api-docs.json` returns OpenAPI JSON
  - `GET http://localhost:3000/api-docs` loads Swagger UI

### Basic correctness checks
- Each path has correct HTTP method.
- Protected routes show lock icon in UI.
- Example payloads match actual behavior.

## Exporting spec to repo (optional but recommended)
Add a node script in gateway (example):
- `npm run openapi:export`

Behavior:
- imports swagger generator
- writes JSON to `docs/api/api-gateway.openapi.json`

This provides submission evidence even if the runtime docs are not accessible.

## Rollout order (recommended)
1. Add Swagger UI and verify it loads.
2. Document Auth endpoints (fast feedback loop).
3. Add Announcements.
4. Add Notifications.
5. Add Feedback.
6. Add Analytics.
7. Export spec artifact.

## Open questions for you (confirm before implementation)
1. **Docs location:** Should Swagger UI be exposed on the gateway at `/api-docs`, or do you want it under `/api/docs`?
2. **Environment:** Should Swagger be enabled in all environments, or only when `NODE_ENV !== 'production'`?
3. **Scope:** Gateway-only for now (recommended), or also per-service docs in the same pass?
